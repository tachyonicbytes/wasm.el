//! wasm3-el.c
#include <assert.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include <emacs-module.h>
#include <wasm3.h>

/* Declare mandatory GPL symbol.  */
int plugin_is_GPL_compatible;

/* New emacs lisp function. All function exposed to Emacs must have this
 * prototype. */
static emacs_value Fwasm3_test(emacs_env *env, int nargs, emacs_value args[],
                               void *data) {

  assert(M3_VERSION_MAJOR == 0 && M3_VERSION_MINOR == 5 &&
         M3_VERSION_REV == 0 && "Tested only on version wasm3 0.5.0");

  IM3Environment e = m3_NewEnvironment();

  IM3Runtime r = m3_NewRuntime(e, 1024, NULL);

  /* Fibonacci module. This module contains the "fib" function */
  const uint8_t wasm_bytes_fib[] = {
      0x0,  0x61, 0x73, 0x6d, 0x1,  0x0,  0x0,  0x0,  0x1,  0xf,  0x3,  0x60,
      0x0,  0x0,  0x60, 0x1,  0x7f, 0x1,  0x7f, 0x60, 0x2,  0x7f, 0x7f, 0x1,
      0x7f, 0x3,  0x6,  0x5,  0x1,  0x2,  0x0,  0x1,  0x0,  0x5,  0x6,  0x1,
      0x1,  0x80, 0x2,  0x80, 0x2,  0x6,  0x9,  0x1,  0x7f, 0x1,  0x41, 0x80,
      0x8c, 0xc0, 0x2,  0xb,  0x7,  0x41, 0x6,  0x6,  0x6d, 0x65, 0x6d, 0x6f,
      0x72, 0x79, 0x2,  0x0,  0x11, 0x5f, 0x5f, 0x77, 0x61, 0x73, 0x6d, 0x5f,
      0x63, 0x61, 0x6c, 0x6c, 0x5f, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x0,  0x2,
      0x3,  0x66, 0x69, 0x62, 0x0,  0x0,  0x4,  0x6d, 0x61, 0x69, 0x6e, 0x0,
      0x1,  0xa,  0x73, 0x74, 0x61, 0x63, 0x6b, 0x41, 0x6c, 0x6c, 0x6f, 0x63,
      0x0,  0x3,  0x6,  0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x0,  0x4,  0xa,
      0x8a, 0x1,  0x5,  0x1c, 0x0,  0x20, 0x0,  0x41, 0x2,  0x4f, 0x4,  0x40,
      0x20, 0x0,  0x41, 0x7f, 0x6a, 0x10, 0x0,  0x20, 0x0,  0x41, 0x7e, 0x6a,
      0x10, 0x0,  0x6a, 0xf,  0xb,  0x20, 0x0,  0xb,  0x4c, 0x1,  0x2,  0x7f,
      0x41, 0x0,  0x21, 0x0,  0x20, 0x1,  0x28, 0x2,  0x4,  0x22, 0x3,  0x2d,
      0x0,  0x0,  0x22, 0x2,  0x45, 0x4,  0x40, 0x41, 0x0,  0x10, 0x0,  0xf,
      0xb,  0x41, 0x0,  0x21, 0x1,  0x3,  0x40, 0x20, 0x1,  0x41, 0xa,  0x6c,
      0x20, 0x2,  0x41, 0x18, 0x74, 0x41, 0x18, 0x75, 0x6a, 0x41, 0x50, 0x6a,
      0x21, 0x1,  0x20, 0x3,  0x20, 0x0,  0x41, 0x1,  0x6a, 0x22, 0x0,  0x6a,
      0x2d, 0x0,  0x0,  0x22, 0x2,  0xd,  0x0,  0xb,  0x20, 0x1,  0x10, 0x0,
      0xb,  0x3,  0x0,  0x1,  0xb,  0x10, 0x0,  0x23, 0x0,  0x20, 0x0,  0x6b,
      0x41, 0x70, 0x71, 0x22, 0x0,  0x24, 0x0,  0x20, 0x0,  0xb,  0x9,  0x0,
      0x41, 0x0,  0x41, 0x0,  0x10, 0x1,  0x1a, 0xb,  0xb,  0xa,  0x1,  0x0,
      0x41, 0x80, 0xc,  0xb,  0x3,  0xc0, 0x6,  0x50};

  IM3Module m;
  M3Result result =
      m3_ParseModule(e, &m, wasm_bytes_fib, sizeof(wasm_bytes_fib));
  if (result) {
    /* printf("Error initializing module: %s\n", result); */
    return 1;
  }
  result = m3_LoadModule(r, m);
  if (result) {
    /* printf("Error loading module: %s\n", result); */
    return 1;
  }
  printf("%s\n", m3_GetModuleName(m));

  IM3Function f = NULL;
  result = m3_FindFunction(&f, r, "fib");
  if (result) {
    /* printf("Error finding function: %s\n", result); */
    return 1;
  }

  static uint32_t argbuff[10];
  static const void *argptrs[10];
  memset(argbuff, 0, sizeof(argbuff));
  memset(argptrs, 0, sizeof(argptrs));

  for (int i = 0; i < 10; i++) {
    argptrs[i] = &argbuff[i];
  }

  argbuff[0] = 5;

  result = m3_Call(f, 1, argptrs);
  if (result) {
    /* printf("Error calling function: %s\n", result); */
    return 1;
  }
  static uint64_t valbuff[10];
  static const void *valptrs[10];
  for (int i = 0; i < 1; i++) {
    valptrs[i] = &valbuff[i];
  }
  result = m3_GetResults(f, 1, valptrs);
  if (result) {
    /* printf("Error getting results: %s\n", result); */
    return 1;
  }
  /* printf("%lld\n", valbuff[0]); */

  return env->make_integer(env, valbuff[0]);
}

/* Bind NAME to FUN.  */
static void bind_function(emacs_env *env, const char *name, emacs_value Sfun) {
  /* Set the function cell of the symbol named NAME to SFUN using
     the 'fset' function.  */

  /* Convert the strings to symbols by interning them */
  emacs_value Qfset = env->intern(env, "fset");
  emacs_value Qsym = env->intern(env, name);

  /* Prepare the arguments array */
  emacs_value args[] = {Qsym, Sfun};

  /* Make the call (2 == nb of arguments) */
  env->funcall(env, Qfset, 2, args);
}

/* Provide FEATURE to Emacs.  */
static void provide(emacs_env *env, const char *feature) {
  /* call 'provide' with FEATURE converted to a symbol */

  emacs_value Qfeat = env->intern(env, feature);
  emacs_value Qprovide = env->intern(env, "provide");
  emacs_value args[] = {Qfeat};

  env->funcall(env, Qprovide, 1, args);
}

int emacs_module_init(struct emacs_runtime *ert) {
  emacs_env *env = ert->get_environment(ert);

  /* create a lambda (returns an emacs_value) */
  emacs_value fun = env->make_function(
      env, 0,      /* min. number of arguments */
      0,           /* max. number of arguments */
      Fwasm3_test, /* actual function pointer */
      "doc",       /* docstring */
      NULL         /* user pointer of your choice (data param in Fmymod_test) */
  );

  bind_function(env, "wasm3-test", fun);
  provide(env, "wasm3");

  /* loaded successfully */
  return 0;
}
